Below is the **clean, practical ERD** specifically optimized for a **hybrid job recommendation engine** (content-based + collaborative filtering + preference-based ranking).

It has **zero bloat**, focuses only on **what the engine needs**, and is ready to implement in PostgreSQL.

---

# âœ… Complete ERD for a Job Recommendation System

---

# ðŸ“Œ 1. High-Level Diagram (text-based ERD)

```mermaid
erDiagram
    USERS ||--o{ JOB_INTERACTIONS : interacts
    USERS ||--o{ USER_PREFERENCES : has
    USERS ||--|| USER_CONTENT_EMBEDDINGS : has
    USERS ||--|| USER_CF_FACTORS : has

    JOBS ||--o{ JOB_INTERACTIONS : receives
    JOBS ||--o{ JOB_SKILLS : lists
    JOBS ||--|| JOB_CONTENT_EMBEDDINGS : has
    JOBS ||--|| JOB_CF_FACTORS : has

    COMPANIES ||--o{ JOBS : offers

    USERS {
        UUID id PK
        TEXT email
        JSONB profile
        TIMESTAMPTZ created_at
    }

    USER_PREFERENCES {
        UUID user_id PK FK
        JSONB values
        JSONB industries_like
        JSONB industries_dislike
        JSONB skills_like
        JSONB skills_dislike
        JSONB preferred_role_types
        JSONB preferred_locations
        TEXT preferred_company_size
        BOOLEAN wants_clearance_roles
        JSONB hidden_company_ids
        INTEGER min_salary
    }

    JOBS {
        UUID id PK
        UUID company_id FK
        TEXT title
        TEXT description
        TEXT location
        TEXT employment_type
        TEXT level
        TEXT industry
        INTEGER min_salary
        INTEGER max_salary
        BOOLEAN requires_clearance
        TIMESTAMPTZ created_at
        TIMESTAMPTZ expires_at
    }

    JOB_SKILLS {
        UUID job_id FK
        TEXT skill
        PK (job_id, skill)
    }

    JOB_INTERACTIONS {
        BIGSERIAL id PK
        UUID user_id FK
        UUID job_id FK
        TEXT type
        REAL weight
        TIMESTAMPTZ created_at
    }

    COMPANIES {
        UUID id PK
        TEXT name
        TEXT size
        BOOLEAN has_dei_tag
    }

    JOB_CONTENT_EMBEDDINGS {
        UUID job_id PK FK
        VECTOR(768) embedding
    }

    USER_CONTENT_EMBEDDINGS {
        UUID user_id PK FK
        VECTOR(768) embedding
    }

    JOB_CF_FACTORS {
        UUID job_id PK FK
        VECTOR(64) factors
    }

    USER_CF_FACTORS {
        UUID user_id PK FK
        VECTOR(64) factors
    }
```

---

# ðŸ“Œ 2. Description of Each Table (What itâ€™s for)

## **1. USERS**

Minimal user profile, but includes JSON `profile` for arbitrary structured info.

Use case:

- Connect to user interactions
- Feed into content embedding generation

---

## **2. USER_PREFERENCES**

Direct mapping of your form:

- Values (D&I)
- Role interest (ex: Aerospace Engineering)
- Location preferences (Atlanta)
- Preferred company size
- Preferred industries
- Skills liked / disliked
- Salary expectation
- Hidden companies
- Clearance preference

This makes **filtering + boosting** easy.

---

## **3. JOBS**

Contains all content needed for:

- Model text encoding â†’ embeddings
- Feature-based scoring (industry, role type, salary)
- Search filtering (location, clearance, etc.)

---

## **4. JOB_SKILLS**

Normalized many-to-many:

- Helps skill overlap calculation
- Improves content embeddings (skills treated as tokens)

---

## **5. JOB_INTERACTIONS**

This powers collaborative filtering.

Examples:

- `view`
- `click`
- `save`
- `apply`

Weighted interactions â†’ implicit feedback matrix.

---

## **6. COMPANIES**

Used for soft boosts/filters:

- Size
- DEI tag
- Hidden companies

---

## **7. JOB_CONTENT_EMBEDDINGS**

Stores vector (pgvector) for content-based filtering:

- 384 or 768 dim embedding (BERT/Longformer)
- Precomputed daily/weekly

Used for:

- Similar job search
- Candidate generation for recommendations

---

## **8. USER_CONTENT_EMBEDDINGS**

Used for cold-start and structured preference matching:

- Encode the user's form answers
- Combine with resume or clicked jobs

---

## **9. JOB_CF_FACTORS & USER_CF_FACTORS**

Output of matrix factorization (ALS/BPR):

- `vector(64)` latent factors
- Generated by Python pipeline (`implicit` library)

Used for collaborative filtering part of hybrid model.

---

# ðŸ“Œ 3. How This ERD Supports All Recommendation Use Cases

### âœ” Cold start users

Use:

- USER_PREFERENCES
- USER_CONTENT_EMBEDDINGS
- JOB_CONTENT_EMBEDDINGS

Generates relevant recommendations even with **zero clicks**.

---

### âœ” Cold start jobs

Use:

- JOB_CONTENT_EMBEDDINGS
- JOB_SKILLS
- JOBS fields

CF factors missing â†’ fallback to content + preferences.

---

### âœ” Active users with history

Use:

- USER_CF_FACTORS
- JOB_CF_FACTORS
- JOB_INTERACTIONS

Collaborative filtering kicks in.

---

### âœ” Full hybrid scoring

The ERD enables:

```
final_score =
  Î± * cosine(user_content_embed, job_content_embed)
  + (1-Î±) * dot(user_cf_factor, job_cf_factor)
  + boosts from preferences
  - penalties from dislikes
```

All these reference this ERD.

---

# ðŸ“Œ 4. If you want, I can also provide:

âœ… SQL migrations for all tables
âœ… JSON examples for preferences
âœ… Python training pipeline (ALS + embeddings)
âœ… .NET/NestJS recommendation service code
âœ… Ranking logic implementation
âœ… Query plan for generating candidate set

Just tell me what part you want next.
